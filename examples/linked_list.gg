# Arena-backed Linked List with Iterator Support
#
# This example demonstrates:
#   - Struct field access and mutation via &self
#   - Parallel-array arena (no nested generics needed)
#   - Iterator[T] trait implementation
#   - For-loop desugaring over custom types
#   - Iterator adapters: .fold(), .map()
#
# The arena uses two parallel vectors:
#   values[i] = the data stored at node i
#   nexts[i]  = the index of the next node (-1 = null)
# This avoids Option[Box[Node[T]]] which requires nested generics.

struct LinkedList:
    Vector[int] values
    Vector[int] nexts
    int head
    int len
    int cursor

equip LinkedList:
    # Prepend a value at the front of the list.
    # Allocates a new arena slot, links it before the current head.
    void push_front(&self, int val):
        int idx = self.values.len()
        self.values.push(val)
        self.nexts.push(self.head)
        self.head = idx
        self.len = self.len + 1
        self.cursor = self.head

    # Return the number of elements.
    int length(self):
        return self.len

    # Read the value at the head of the list.
    int peek(self):
        return self.values[self.head]

    # Reset the iteration cursor back to the head.
    # Call this before iterating again after a previous traversal.
    void reset(&self):
        self.cursor = self.head

# Implement Iterator[int] so the list works with for-loops and adapters.
equip LinkedList with Iterator[int]:
    Option[int] next(&self):
        if self.cursor == -1:
            return None
        int val = self.values[self.cursor]
        self.cursor = self.nexts[self.cursor]
        return Some(val)

void main():
    # Construct an empty list (head=-1, cursor=-1)
    LinkedList list = LinkedList(Vector[int](), Vector[int](), -1, 0, -1)

    # Build list: 10 -> 20 -> 30
    list.push_front(30)
    list.push_front(20)
    list.push_front(10)

    print(list.length())
    print(list.peek())

    # Iterate with a for-loop (uses Iterator[int].next)
    for x in list:
        print(x)

    # Sum all elements using fold
    list.reset()
    int total = list.fold(0, (int acc, int x): acc + x)
    print(total)

    # Double each element using map
    list.reset()
    Vector[int] doubled = list.map((int x): x * 2)
    print(doubled.get(0))
    print(doubled.get(1))
    print(doubled.get(2))
