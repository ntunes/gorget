/// Embedded runtime header included at the top of every generated C file.
pub const RUNTIME: &str = r#"// Generated by Gorget compiler v0.1.0
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <inttypes.h>
#include <stdarg.h>
#include <setjmp.h>

// ── GorgetString ─────────────────────────────────────────────
typedef struct {
    char* data;
    size_t len;
    size_t cap;
} GorgetString;

static inline GorgetString gorget_string_new(const char* s) {
    if (s == NULL) return (GorgetString){NULL, 0, 0};
    size_t len = strlen(s);
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, s, len + 1);
    return (GorgetString){data, len, cap};
}

static inline void gorget_string_free(GorgetString* s) {
    free(s->data);
    s->data = NULL;
    s->len = 0;
    s->cap = 0;
}

static inline GorgetString gorget_string_concat(const GorgetString* a, const GorgetString* b) {
    size_t len = a->len + b->len;
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, a->data, a->len);
    memcpy(data + a->len, b->data, b->len + 1);
    return (GorgetString){data, len, cap};
}

static inline bool gorget_string_eq(const GorgetString* a, const GorgetString* b) {
    return a->len == b->len && memcmp(a->data, b->data, a->len) == 0;
}

static inline const char* gorget_string_cstr(const GorgetString* s) {
    return s->data;
}

static inline GorgetString gorget_string_format(const char* fmt, ...) {
    va_list args1, args2;
    va_start(args1, fmt);
    va_copy(args2, args1);
    int len = vsnprintf(NULL, 0, fmt, args1);
    va_end(args1);
    size_t cap = (size_t)len + 1;
    char* data = (char*)malloc(cap);
    vsnprintf(data, cap, fmt, args2);
    va_end(args2);
    return (GorgetString){data, (size_t)len, cap};
}

// ── Panic helper ─────────────────────────────────────────────
static inline void gorget_panic(const char* msg) {
    fprintf(stderr, "gorget: panic: %s\n", msg);
    exit(1);
}

// ── GorgetArray ──────────────────────────────────────────────
typedef struct {
    void* data;
    size_t len;
    size_t cap;
    size_t elem_size;
} GorgetArray;

static inline GorgetArray gorget_array_new(size_t elem_size) {
    return (GorgetArray){NULL, 0, 0, elem_size};
}

static inline void gorget_array_push(GorgetArray* arr, const void* elem) {
    if (arr->len >= arr->cap) {
        size_t new_cap = arr->cap == 0 ? 8 : arr->cap * 2;
        arr->data = realloc(arr->data, new_cap * arr->elem_size);
        arr->cap = new_cap;
    }
    memcpy((char*)arr->data + arr->len * arr->elem_size, elem, arr->elem_size);
    arr->len++;
}

static inline void* gorget_array_get(const GorgetArray* arr, size_t index) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    return (char*)arr->data + index * arr->elem_size;
}

static inline size_t gorget_array_len(const GorgetArray* arr) {
    return arr->len;
}

static inline void gorget_array_set(GorgetArray* arr, size_t index, const void* elem) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    memcpy((char*)arr->data + index * arr->elem_size, elem, arr->elem_size);
}

static inline void gorget_array_remove(GorgetArray* arr, size_t index) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    if (index + 1 < arr->len) {
        memmove((char*)arr->data + index * arr->elem_size,
                (char*)arr->data + (index + 1) * arr->elem_size,
                (arr->len - index - 1) * arr->elem_size);
    }
    arr->len--;
}

static inline void gorget_array_clear(GorgetArray* arr) {
    arr->len = 0;
}

static inline void gorget_array_free(GorgetArray* arr) {
    free(arr->data);
    arr->data = NULL;
    arr->len = 0;
    arr->cap = 0;
}

static inline bool gorget_array_contains(const GorgetArray* a, const void* needle, size_t elem_size) {
    for (size_t i = 0; i < a->len; i++) {
        if (memcmp((char*)a->data + i * a->elem_size, needle, elem_size) == 0) return true;
    }
    return false;
}

// ── GORGET_ARRAY_AT macro ────────────────────────────────────
#define GORGET_ARRAY_AT(type, arr, i) (*(type*)gorget_array_get(&(arr), (i)))

// ── GorgetMap (open-addressing hash map) ─────────────────────
typedef struct {
    void* keys;
    void* values;
    uint8_t* states;  // 0=empty, 1=occupied, 2=tombstone
    size_t count;
    size_t cap;
    size_t key_size;
    size_t val_size;
} GorgetMap;

static inline uint64_t __gorget_fnv1a(const void* data, size_t len) {
    uint64_t hash = 14695981039346656037ULL;
    const uint8_t* p = (const uint8_t*)data;
    for (size_t i = 0; i < len; i++) {
        hash ^= p[i];
        hash *= 1099511628211ULL;
    }
    return hash;
}

static inline void __gorget_map_grow(GorgetMap* m) {
    size_t old_cap = m->cap;
    void* old_keys = m->keys;
    void* old_values = m->values;
    uint8_t* old_states = m->states;

    size_t new_cap = old_cap == 0 ? 16 : old_cap * 2;
    m->keys = calloc(new_cap, m->key_size);
    m->values = m->val_size > 0 ? calloc(new_cap, m->val_size) : NULL;
    m->states = (uint8_t*)calloc(new_cap, 1);
    m->cap = new_cap;
    m->count = 0;

    for (size_t i = 0; i < old_cap; i++) {
        if (old_states[i] == 1) {
            const void* key = (const char*)old_keys + i * m->key_size;
            uint64_t h = __gorget_fnv1a(key, m->key_size);
            size_t idx = (size_t)(h % new_cap);
            while (m->states[idx] != 0) {
                idx = (idx + 1) % new_cap;
            }
            memcpy((char*)m->keys + idx * m->key_size, key, m->key_size);
            if (m->val_size > 0) {
                const void* val = (const char*)old_values + i * m->val_size;
                memcpy((char*)m->values + idx * m->val_size, val, m->val_size);
            }
            m->states[idx] = 1;
            m->count++;
        }
    }

    free(old_keys);
    free(old_values);
    free(old_states);
}

static inline GorgetMap gorget_map_new(size_t key_size, size_t val_size) {
    return (GorgetMap){NULL, NULL, NULL, 0, 0, key_size, val_size};
}

static inline void gorget_map_put(GorgetMap* m, const void* key, const void* value) {
    if (m->cap == 0 || m->count * 4 >= m->cap * 3) {
        __gorget_map_grow(m);
    }
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    size_t first_tombstone = (size_t)-1;
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) {
            size_t target = first_tombstone != (size_t)-1 ? first_tombstone : idx;
            memcpy((char*)m->keys + target * m->key_size, key, m->key_size);
            if (m->val_size > 0 && value != NULL) {
                memcpy((char*)m->values + target * m->val_size, value, m->val_size);
            }
            m->states[target] = 1;
            m->count++;
            return;
        }
        if (m->states[idx] == 2 && first_tombstone == (size_t)-1) {
            first_tombstone = idx;
        }
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            if (m->val_size > 0 && value != NULL) {
                memcpy((char*)m->values + idx * m->val_size, value, m->val_size);
            }
            return;
        }
        idx = (idx + 1) % m->cap;
    }
    if (first_tombstone != (size_t)-1) {
        memcpy((char*)m->keys + first_tombstone * m->key_size, key, m->key_size);
        if (m->val_size > 0 && value != NULL) {
            memcpy((char*)m->values + first_tombstone * m->val_size, value, m->val_size);
        }
        m->states[first_tombstone] = 1;
        m->count++;
    }
}

static inline void* gorget_map_get(const GorgetMap* m, const void* key) {
    if (m->cap == 0) return NULL;
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) return NULL;
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            if (m->val_size == 0) return (void*)1;  // Set mode: non-NULL means present
            return (char*)m->values + idx * m->val_size;
        }
        idx = (idx + 1) % m->cap;
    }
    return NULL;
}

static inline bool gorget_map_contains(const GorgetMap* m, const void* key) {
    return gorget_map_get(m, key) != NULL;
}

static inline size_t gorget_map_len(const GorgetMap* m) {
    return m->count;
}

static inline bool gorget_map_remove(GorgetMap* m, const void* key) {
    if (m->cap == 0) return false;
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) return false;
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            m->states[idx] = 2;  // tombstone
            m->count--;
            return true;
        }
        idx = (idx + 1) % m->cap;
    }
    return false;
}

static inline void gorget_map_clear(GorgetMap* m) {
    if (m->states) memset(m->states, 0, m->cap);
    m->count = 0;
}

static inline void gorget_map_free(GorgetMap* m) {
    free(m->keys);
    free(m->values);
    free(m->states);
    m->keys = NULL;
    m->values = NULL;
    m->states = NULL;
    m->count = 0;
    m->cap = 0;
}

// ── GorgetSet (thin wrapper over GorgetMap) ───────────────────
typedef GorgetMap GorgetSet;

static inline GorgetSet gorget_set_new(size_t elem_size) {
    return gorget_map_new(elem_size, 0);
}

static inline void gorget_set_add(GorgetSet* s, const void* elem) {
    gorget_map_put(s, elem, NULL);
}

static inline bool gorget_set_contains(const GorgetSet* s, const void* elem) {
    return gorget_map_contains(s, elem);
}

static inline bool gorget_set_remove(GorgetSet* s, const void* elem) {
    return gorget_map_remove(s, elem);
}

static inline void gorget_set_clear(GorgetSet* s) {
    gorget_map_clear(s);
}

static inline size_t gorget_set_len(const GorgetSet* s) {
    return gorget_map_len(s);
}

static inline void gorget_set_free(GorgetSet* s) {
    gorget_map_free(s);
}

// ── Error Handling (setjmp/longjmp) ─────────────────────────
typedef struct {
    char message[256];
    int code;
} GorgetError;

static jmp_buf __gorget_jmp_stack[64];
static int __gorget_jmp_top = -1;
static GorgetError __gorget_last_error;

#define GORGET_TRY (__gorget_jmp_top >= 63 ? (fprintf(stderr, "gorget: try stack overflow\n"), exit(1), 0) : (__gorget_jmp_top++, setjmp(__gorget_jmp_stack[__gorget_jmp_top]) == 0))
#define GORGET_CATCH_END (__gorget_jmp_top--)

static inline void gorget_throw(const char* msg, int code) {
    strncpy(__gorget_last_error.message, msg, 255);
    __gorget_last_error.message[255] = '\0';
    __gorget_last_error.code = code;
    if (__gorget_jmp_top >= 0) {
        longjmp(__gorget_jmp_stack[__gorget_jmp_top], 1);
    } else {
        fprintf(stderr, "Unhandled error: %s\n", msg);
        exit(1);
    }
}

#define GORGET_THROW(msg, code) gorget_throw(msg, code)
#define GORGET_CATCH_ERROR() (__gorget_last_error)

// ── GorgetFile ──────────────────────────────────────────────
typedef struct {
    FILE* handle;
    bool  owned;   // false for stdin/stdout/stderr
} GorgetFile;

static inline GorgetFile gorget_file_open(const char* path, const char* mode) {
    FILE* f = fopen(path, mode);
    if (!f) { fprintf(stderr, "Error: cannot open '%s'\n", path); exit(1); }
    return (GorgetFile){f, true};
}

static inline void gorget_file_close(GorgetFile* f) {
    if (f->handle && f->owned) { fclose(f->handle); f->handle = NULL; }
}

static inline const char* gorget_file_read_all(GorgetFile* f) {
    fseek(f->handle, 0, SEEK_END);
    long len = ftell(f->handle);
    fseek(f->handle, 0, SEEK_SET);
    char* buf = (char*)malloc(len + 1);
    fread(buf, 1, len, f->handle);
    buf[len] = '\0';
    return buf;
}

static inline void gorget_file_write(GorgetFile* f, const char* s) {
    fputs(s, f->handle);
}

// Free functions
static inline const char* gorget_read_file(const char* path) {
    GorgetFile f = gorget_file_open(path, "r");
    const char* content = gorget_file_read_all(&f);
    gorget_file_close(&f);
    return content;
}

static inline void gorget_write_file(const char* path, const char* content) {
    GorgetFile f = gorget_file_open(path, "w");
    gorget_file_write(&f, content);
    gorget_file_close(&f);
}

static inline void gorget_append_file(const char* path, const char* content) {
    GorgetFile f = gorget_file_open(path, "a");
    gorget_file_write(&f, content);
    gorget_file_close(&f);
}

static inline bool gorget_file_exists(const char* path) {
    FILE* f = fopen(path, "r");
    if (f) { fclose(f); return true; }
    return false;
}

static inline bool gorget_delete_file(const char* path) {
    return remove(path) == 0;
}

// ── GorgetClosure ────────────────────────────────────────────
typedef struct {
    void* fn_ptr;
    void* env;
} GorgetClosure;

"#;
