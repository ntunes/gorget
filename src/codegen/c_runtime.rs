/// Everything before the panic helper — includes, types, string helpers.
pub const RUNTIME_PREAMBLE: &str = r#"// Generated by Gorget compiler v0.1.0
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <inttypes.h>
#include <stdarg.h>
#include <setjmp.h>
#include <dirent.h>
#include <ctype.h>
#include <sys/wait.h>
#include <unistd.h>
#include <time.h>
#include <math.h>
#include <sys/ioctl.h>

// ── GorgetString ─────────────────────────────────────────────
typedef struct {
    char* data;
    size_t len;
    size_t cap;
} GorgetString;

static inline GorgetString gorget_string_new(const char* s) {
    if (s == NULL) return (GorgetString){NULL, 0, 0};
    size_t len = strlen(s);
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, s, len + 1);
    return (GorgetString){data, len, cap};
}

static inline void gorget_string_free(GorgetString* s) {
    free(s->data);
    s->data = NULL;
    s->len = 0;
    s->cap = 0;
}

static inline GorgetString gorget_string_concat(const GorgetString* a, const GorgetString* b) {
    size_t len = a->len + b->len;
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, a->data, a->len);
    memcpy(data + a->len, b->data, b->len + 1);
    return (GorgetString){data, len, cap};
}

static inline bool gorget_string_eq(const GorgetString* a, const GorgetString* b) {
    return a->len == b->len && memcmp(a->data, b->data, a->len) == 0;
}

static inline const char* gorget_string_cstr(const GorgetString* s) {
    return s->data;
}

static inline GorgetString gorget_string_format(const char* fmt, ...) {
    va_list args1, args2;
    va_start(args1, fmt);
    va_copy(args2, args1);
    int len = vsnprintf(NULL, 0, fmt, args1);
    va_end(args1);
    size_t cap = (size_t)len + 1;
    char* data = (char*)malloc(cap);
    vsnprintf(data, cap, fmt, args2);
    va_end(args2);
    return (GorgetString){data, (size_t)len, cap};
}

static inline const char* gorget_format(const char* fmt, ...) {
    va_list args1, args2;
    va_start(args1, fmt);
    va_copy(args2, args1);
    int len = vsnprintf(NULL, 0, fmt, args1);
    va_end(args1);
    char* data = (char*)malloc((size_t)len + 1);
    vsnprintf(data, (size_t)len + 1, fmt, args2);
    va_end(args2);
    return data;
}

// ── String concatenation ────────────────────────────────────
static inline const char* gorget_str_concat(const char* a, const char* b) {
    size_t la = strlen(a), lb = strlen(b);
    char* out = (char*)malloc(la + lb + 1);
    memcpy(out, a, la);
    memcpy(out + la, b, lb + 1);
    return out;
}

// ── String helpers ──────────────────────────────────────────
static inline bool gorget_string_starts_with(const char* s, const char* prefix) {
    return strncmp(s, prefix, strlen(prefix)) == 0;
}

static inline bool gorget_string_ends_with(const char* s, const char* suffix) {
    size_t slen = strlen(s), plen = strlen(suffix);
    if (plen > slen) return false;
    return memcmp(s + slen - plen, suffix, plen) == 0;
}

static inline const char* gorget_string_trim(const char* s) {
    while (*s == ' ' || *s == '\t' || *s == '\n' || *s == '\r') s++;
    size_t len = strlen(s);
    while (len > 0 && (s[len-1] == ' ' || s[len-1] == '\t' || s[len-1] == '\n' || s[len-1] == '\r')) len--;
    char* out = (char*)malloc(len + 1);
    memcpy(out, s, len);
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_lstrip_ws(const char* s) {
    while (*s == ' ' || *s == '\t' || *s == '\n' || *s == '\r') s++;
    char* out = (char*)malloc(strlen(s) + 1);
    strcpy(out, s);
    return out;
}

static inline const char* gorget_string_rstrip_ws(const char* s) {
    size_t len = strlen(s);
    while (len > 0 && (s[len-1] == ' ' || s[len-1] == '\t' || s[len-1] == '\n' || s[len-1] == '\r')) len--;
    char* out = (char*)malloc(len + 1);
    memcpy(out, s, len);
    out[len] = '\0';
    return out;
}

static inline bool gorget_char_in_set(char c, const char* chars) {
    for (const char* p = chars; *p; p++) {
        if (*p == c) return true;
    }
    return false;
}

static inline const char* gorget_string_strip(const char* s, const char* chars) {
    while (*s && gorget_char_in_set(*s, chars)) s++;
    size_t len = strlen(s);
    while (len > 0 && gorget_char_in_set(s[len-1], chars)) len--;
    char* out = (char*)malloc(len + 1);
    memcpy(out, s, len);
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_lstrip(const char* s, const char* chars) {
    while (*s && gorget_char_in_set(*s, chars)) s++;
    char* out = (char*)malloc(strlen(s) + 1);
    strcpy(out, s);
    return out;
}

static inline const char* gorget_string_rstrip(const char* s, const char* chars) {
    size_t len = strlen(s);
    while (len > 0 && gorget_char_in_set(s[len-1], chars)) len--;
    char* out = (char*)malloc(len + 1);
    memcpy(out, s, len);
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_to_upper(const char* s) {
    size_t len = strlen(s);
    char* out = (char*)malloc(len + 1);
    for (size_t i = 0; i < len; i++) out[i] = (s[i] >= 'a' && s[i] <= 'z') ? s[i] - 32 : s[i];
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_to_lower(const char* s) {
    size_t len = strlen(s);
    char* out = (char*)malloc(len + 1);
    for (size_t i = 0; i < len; i++) out[i] = (s[i] >= 'A' && s[i] <= 'Z') ? s[i] + 32 : s[i];
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_replace(const char* s, const char* old, const char* new_s) {
    size_t old_len = strlen(old);
    size_t new_len = strlen(new_s);
    if (old_len == 0) {
        char* dup = (char*)malloc(strlen(s) + 1);
        strcpy(dup, s);
        return dup;
    }
    // Count occurrences
    size_t count = 0;
    const char* p = s;
    while ((p = strstr(p, old)) != NULL) { count++; p += old_len; }
    // Build result
    size_t result_len = strlen(s) + count * (new_len - old_len);
    char* out = (char*)malloc(result_len + 1);
    char* dst = out;
    p = s;
    while (1) {
        const char* found = strstr(p, old);
        if (!found) { strcpy(dst, p); break; }
        size_t chunk = (size_t)(found - p);
        memcpy(dst, p, chunk);
        dst += chunk;
        memcpy(dst, new_s, new_len);
        dst += new_len;
        p = found + old_len;
    }
    return out;
}

// ── String indexing / slicing ────────────────────────────────
static inline char gorget_string_at(const char* s, int64_t index) {
    size_t len = strlen(s);
    if (index < 0 || (size_t)index >= len) {
        fprintf(stderr, "gorget: panic: string index out of bounds: index %" PRId64 ", length %zu\n", index, len);
        exit(1);
    }
    return s[index];
}

static inline const char* gorget_string_slice(const char* s, int64_t start, int64_t end) {
    size_t len = strlen(s);
    if (start < 0 || end < 0 || (size_t)start > len || (size_t)end > len || start > end) {
        fprintf(stderr, "gorget: panic: string slice out of bounds: [%" PRId64 "..%" PRId64 "], length %zu\n", start, end, len);
        exit(1);
    }
    size_t slice_len = (size_t)(end - start);
    char* result = (char*)malloc(slice_len + 1);
    memcpy(result, s + start, slice_len);
    result[slice_len] = '\0';
    return result;
}

// ── Additional string methods ────────────────────────────────
static inline int64_t gorget_string_index_of(const char* s, const char* needle) {
    const char* p = strstr(s, needle);
    if (p == NULL) return -1;
    return (int64_t)(p - s);
}

static inline int64_t gorget_string_count(const char* s, const char* needle) {
    int64_t count = 0;
    size_t needle_len = strlen(needle);
    if (needle_len == 0) return 0;
    const char* p = s;
    while ((p = strstr(p, needle)) != NULL) {
        count++;
        p += needle_len;
    }
    return count;
}

static inline const char* gorget_string_repeat(const char* s, int64_t n) {
    if (n <= 0) {
        char* empty = (char*)malloc(1);
        empty[0] = '\0';
        return empty;
    }
    size_t len = strlen(s);
    size_t total = len * (size_t)n;
    char* result = (char*)malloc(total + 1);
    for (int64_t i = 0; i < n; i++) {
        memcpy(result + i * len, s, len);
    }
    result[total] = '\0';
    return result;
}

"#;

/// Normal panic handler — exits the process.
pub const PANIC_NORMAL: &str = r#"
// ── Panic helper ─────────────────────────────────────────────
static inline void gorget_panic(const char* msg) {
    fprintf(stderr, "gorget: panic: %s\n", msg);
    exit(1);
}
"#;

/// Test panic handler — uses setjmp/longjmp to recover from assertion failures.
pub const PANIC_TEST: &str = r#"
// ── Panic helper (test mode) ─────────────────────────────────
static jmp_buf __gorget_test_jmp;
static const char* __gorget_test_fail_msg = NULL;
static volatile int __gorget_in_test = 0;

static inline void gorget_panic(const char* msg) {
    if (__gorget_in_test) {
        __gorget_test_fail_msg = msg;
        longjmp(__gorget_test_jmp, 1);
    }
    fprintf(stderr, "gorget: panic: %s\n", msg);
    exit(1);
}

// ── Cleanup stack (survives longjmp) ─────────────────────────
typedef void (*__gorget_cleanup_fn)(void*);
typedef struct { __gorget_cleanup_fn fn; void* ptr; } __gorget_cleanup_entry;
static __gorget_cleanup_entry __gorget_cleanup[256];
static int __gorget_cleanup_top = 0;

static inline void __gorget_cleanup_push(__gorget_cleanup_fn fn, void* ptr) {
    if (__gorget_cleanup_top < 256)
        __gorget_cleanup[__gorget_cleanup_top++] =
            (__gorget_cleanup_entry){fn, ptr};
}

static inline void __gorget_cleanup_run(int mark) {
    for (int i = __gorget_cleanup_top - 1; i >= mark; i--)
        __gorget_cleanup[i].fn(__gorget_cleanup[i].ptr);
    __gorget_cleanup_top = mark;
}
"#;

/// Everything after the panic helper — checked arithmetic, collections, etc.
pub const RUNTIME_CORE: &str = r#"
// ── Checked Arithmetic ──────────────────────────────────────
// Inline helpers call __builtin_*_overflow (integer-only).
// _Generic macros dispatch: integer types → checked, double → plain.
// Both branches are valid C, so Clang type-checks them safely.
static inline int64_t gorget_checked_add_i64(int64_t a, int64_t b) {
    int64_t res;
    if (__builtin_add_overflow(a, b, &res)) gorget_panic("integer overflow");
    return res;
}
static inline int64_t gorget_checked_sub_i64(int64_t a, int64_t b) {
    int64_t res;
    if (__builtin_sub_overflow(a, b, &res)) gorget_panic("integer overflow");
    return res;
}
static inline int64_t gorget_checked_mul_i64(int64_t a, int64_t b) {
    int64_t res;
    if (__builtin_mul_overflow(a, b, &res)) gorget_panic("integer overflow");
    return res;
}

#define GORGET_CHECKED_ADD(a, b) _Generic((a), \
    long long: gorget_checked_add_i64((a), (b)), \
    long: gorget_checked_add_i64((a), (b)), \
    default: ((a) + (b)))

#define GORGET_CHECKED_SUB(a, b) _Generic((a), \
    long long: gorget_checked_sub_i64((a), (b)), \
    long: gorget_checked_sub_i64((a), (b)), \
    default: ((a) - (b)))

#define GORGET_CHECKED_MUL(a, b) _Generic((a), \
    long long: gorget_checked_mul_i64((a), (b)), \
    long: gorget_checked_mul_i64((a), (b)), \
    default: ((a) * (b)))

#define GORGET_CHECKED_ADD_ASSIGN(t, v) \
    ((t) = _Generic((t), \
        long long: gorget_checked_add_i64((t), (v)), \
        long: gorget_checked_add_i64((t), (v)), \
        default: ((t) + (v))))

#define GORGET_CHECKED_SUB_ASSIGN(t, v) \
    ((t) = _Generic((t), \
        long long: gorget_checked_sub_i64((t), (v)), \
        long: gorget_checked_sub_i64((t), (v)), \
        default: ((t) - (v))))

#define GORGET_CHECKED_MUL_ASSIGN(t, v) \
    ((t) = _Generic((t), \
        long long: gorget_checked_mul_i64((t), (v)), \
        long: gorget_checked_mul_i64((t), (v)), \
        default: ((t) * (v))))

// ── GorgetArray ──────────────────────────────────────────────
typedef struct {
    void* data;
    size_t len;
    size_t cap;
    size_t elem_size;
} GorgetArray;

static inline GorgetArray gorget_array_new(size_t elem_size) {
    return (GorgetArray){NULL, 0, 0, elem_size};
}

static inline void gorget_array_push(GorgetArray* arr, const void* elem) {
    if (arr->len >= arr->cap) {
        size_t new_cap = arr->cap == 0 ? 8 : arr->cap * 2;
        arr->data = realloc(arr->data, new_cap * arr->elem_size);
        arr->cap = new_cap;
    }
    memcpy((char*)arr->data + arr->len * arr->elem_size, elem, arr->elem_size);
    arr->len++;
}

static inline void* gorget_array_get(const GorgetArray* arr, size_t index) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    return (char*)arr->data + index * arr->elem_size;
}

static inline size_t gorget_array_len(const GorgetArray* arr) {
    return arr->len;
}

static inline void gorget_array_set(GorgetArray* arr, size_t index, const void* elem) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    memcpy((char*)arr->data + index * arr->elem_size, elem, arr->elem_size);
}

static inline void gorget_array_remove(GorgetArray* arr, size_t index) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    if (index + 1 < arr->len) {
        memmove((char*)arr->data + index * arr->elem_size,
                (char*)arr->data + (index + 1) * arr->elem_size,
                (arr->len - index - 1) * arr->elem_size);
    }
    arr->len--;
}

static inline void gorget_array_clear(GorgetArray* arr) {
    arr->len = 0;
}

static inline void gorget_array_free(GorgetArray* arr) {
    free(arr->data);
    arr->data = NULL;
    arr->len = 0;
    arr->cap = 0;
}

static inline bool gorget_array_contains(const GorgetArray* a, const void* needle, size_t elem_size) {
    for (size_t i = 0; i < a->len; i++) {
        if (memcmp((char*)a->data + i * a->elem_size, needle, elem_size) == 0) return true;
    }
    return false;
}

static inline void gorget_array_reserve(GorgetArray* arr, size_t new_cap) {
    if (new_cap > arr->cap) {
        arr->data = realloc(arr->data, new_cap * arr->elem_size);
        arr->cap = new_cap;
    }
}

static inline GorgetArray gorget_array_with_capacity(size_t elem_size, size_t capacity) {
    GorgetArray arr = {NULL, 0, 0, elem_size};
    if (capacity > 0) {
        arr.data = malloc(capacity * elem_size);
        arr.cap = capacity;
    }
    return arr;
}

static inline int64_t gorget_array_index_of(const GorgetArray* a, const void* needle) {
    for (size_t i = 0; i < a->len; i++) {
        if (memcmp((char*)a->data + i * a->elem_size, needle, a->elem_size) == 0) return (int64_t)i;
    }
    return -1;
}

static inline void gorget_array_insert(GorgetArray* arr, size_t index, const void* elem) {
    if (index > arr->len) {
        fprintf(stderr, "gorget: panic: insert index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    if (arr->len >= arr->cap) {
        size_t new_cap = arr->cap == 0 ? 8 : arr->cap * 2;
        arr->data = realloc(arr->data, new_cap * arr->elem_size);
        arr->cap = new_cap;
    }
    if (index < arr->len) {
        memmove((char*)arr->data + (index + 1) * arr->elem_size,
                (char*)arr->data + index * arr->elem_size,
                (arr->len - index) * arr->elem_size);
    }
    memcpy((char*)arr->data + index * arr->elem_size, elem, arr->elem_size);
    arr->len++;
}

static inline void gorget_array_extend(GorgetArray* dst, const GorgetArray* src) {
    if (src->len == 0) return;
    size_t needed = dst->len + src->len;
    if (needed > dst->cap) {
        size_t new_cap = dst->cap == 0 ? 8 : dst->cap;
        while (new_cap < needed) new_cap *= 2;
        dst->data = realloc(dst->data, new_cap * dst->elem_size);
        dst->cap = new_cap;
    }
    memcpy((char*)dst->data + dst->len * dst->elem_size, src->data, src->len * src->elem_size);
    dst->len = needed;
}

static inline GorgetArray gorget_array_slice(const GorgetArray* arr, int64_t start, int64_t end) {
    if (start < 0 || end < 0 || (size_t)start > arr->len || (size_t)end > arr->len || start > end) {
        fprintf(stderr, "gorget: panic: vector slice out of bounds: [%" PRId64 "..%" PRId64 "], length %zu\n", start, end, arr->len);
        exit(1);
    }
    size_t slice_len = (size_t)(end - start);
    GorgetArray result = {NULL, 0, 0, arr->elem_size};
    if (slice_len > 0) {
        result.data = malloc(slice_len * arr->elem_size);
        memcpy(result.data, (char*)arr->data + (size_t)start * arr->elem_size, slice_len * arr->elem_size);
        result.len = slice_len;
        result.cap = slice_len;
    }
    return result;
}

static inline GorgetArray gorget_string_split(const char* s, const char* delim) {
    GorgetArray arr = gorget_array_new(sizeof(const char*));
    size_t dlen = strlen(delim);
    if (dlen == 0) {
        size_t slen = strlen(s);
        for (size_t i = 0; i < slen; i++) {
            char* ch = (char*)malloc(2);
            ch[0] = s[i]; ch[1] = '\0';
            gorget_array_push(&arr, &ch);
        }
        return arr;
    }
    const char* p = s;
    while (1) {
        const char* found = strstr(p, delim);
        if (!found) {
            size_t rem = strlen(p);
            char* part = (char*)malloc(rem + 1);
            memcpy(part, p, rem + 1);
            gorget_array_push(&arr, &part);
            break;
        }
        size_t chunk = (size_t)(found - p);
        char* part = (char*)malloc(chunk + 1);
        memcpy(part, p, chunk);
        part[chunk] = '\0';
        gorget_array_push(&arr, &part);
        p = found + dlen;
    }
    return arr;
}

// ── GORGET_ARRAY_AT macro ────────────────────────────────────
#define GORGET_ARRAY_AT(type, arr, i) (*(type*)gorget_array_get(&(arr), (i)))

// ── String join (needs GorgetArray) ─────────────────────────
static inline const char* gorget_string_join(const char* sep, GorgetArray parts) {
    if (parts.len == 0) {
        char* empty = (char*)malloc(1);
        empty[0] = '\0';
        return empty;
    }
    size_t sep_len = strlen(sep);
    size_t total = 0;
    for (size_t i = 0; i < parts.len; i++) {
        const char* part = *(const char**)((char*)parts.data + i * parts.elem_size);
        total += strlen(part);
    }
    total += sep_len * (parts.len - 1);
    char* result = (char*)malloc(total + 1);
    char* dst = result;
    for (size_t i = 0; i < parts.len; i++) {
        if (i > 0) {
            memcpy(dst, sep, sep_len);
            dst += sep_len;
        }
        const char* part = *(const char**)((char*)parts.data + i * parts.elem_size);
        size_t plen = strlen(part);
        memcpy(dst, part, plen);
        dst += plen;
    }
    *dst = '\0';
    return result;
}

// ── GorgetMap (open-addressing hash map) ─────────────────────
typedef struct {
    void* keys;
    void* values;
    uint8_t* states;  // 0=empty, 1=occupied, 2=tombstone
    size_t count;
    size_t cap;
    size_t key_size;
    size_t val_size;
} GorgetMap;

static inline uint64_t __gorget_fnv1a(const void* data, size_t len) {
    uint64_t hash = 14695981039346656037ULL;
    const uint8_t* p = (const uint8_t*)data;
    for (size_t i = 0; i < len; i++) {
        hash ^= p[i];
        hash *= 1099511628211ULL;
    }
    return hash;
}

static inline uint64_t __gorget_hash_str(const char* s) {
    uint64_t hash = 14695981039346656037ULL;
    while (*s) { hash ^= (uint8_t)*s++; hash *= 1099511628211ULL; }
    return hash;
}

static inline void __gorget_map_grow(GorgetMap* m) {
    size_t old_cap = m->cap;
    void* old_keys = m->keys;
    void* old_values = m->values;
    uint8_t* old_states = m->states;

    size_t new_cap = old_cap == 0 ? 16 : old_cap * 2;
    m->keys = calloc(new_cap, m->key_size);
    m->values = m->val_size > 0 ? calloc(new_cap, m->val_size) : NULL;
    m->states = (uint8_t*)calloc(new_cap, 1);
    m->cap = new_cap;
    m->count = 0;

    for (size_t i = 0; i < old_cap; i++) {
        if (old_states[i] == 1) {
            const void* key = (const char*)old_keys + i * m->key_size;
            uint64_t h = __gorget_fnv1a(key, m->key_size);
            size_t idx = (size_t)(h % new_cap);
            while (m->states[idx] != 0) {
                idx = (idx + 1) % new_cap;
            }
            memcpy((char*)m->keys + idx * m->key_size, key, m->key_size);
            if (m->val_size > 0) {
                const void* val = (const char*)old_values + i * m->val_size;
                memcpy((char*)m->values + idx * m->val_size, val, m->val_size);
            }
            m->states[idx] = 1;
            m->count++;
        }
    }

    free(old_keys);
    free(old_values);
    free(old_states);
}

static inline GorgetMap gorget_map_new(size_t key_size, size_t val_size) {
    return (GorgetMap){NULL, NULL, NULL, 0, 0, key_size, val_size};
}

static inline void gorget_map_put(GorgetMap* m, const void* key, const void* value) {
    if (m->cap == 0 || m->count * 4 >= m->cap * 3) {
        __gorget_map_grow(m);
    }
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    size_t first_tombstone = (size_t)-1;
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) {
            size_t target = first_tombstone != (size_t)-1 ? first_tombstone : idx;
            memcpy((char*)m->keys + target * m->key_size, key, m->key_size);
            if (m->val_size > 0 && value != NULL) {
                memcpy((char*)m->values + target * m->val_size, value, m->val_size);
            }
            m->states[target] = 1;
            m->count++;
            return;
        }
        if (m->states[idx] == 2 && first_tombstone == (size_t)-1) {
            first_tombstone = idx;
        }
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            if (m->val_size > 0 && value != NULL) {
                memcpy((char*)m->values + idx * m->val_size, value, m->val_size);
            }
            return;
        }
        idx = (idx + 1) % m->cap;
    }
    if (first_tombstone != (size_t)-1) {
        memcpy((char*)m->keys + first_tombstone * m->key_size, key, m->key_size);
        if (m->val_size > 0 && value != NULL) {
            memcpy((char*)m->values + first_tombstone * m->val_size, value, m->val_size);
        }
        m->states[first_tombstone] = 1;
        m->count++;
    }
}

static inline void* gorget_map_get(const GorgetMap* m, const void* key) {
    if (m->cap == 0) return NULL;
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) return NULL;
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            if (m->val_size == 0) return (void*)1;  // Set mode: non-NULL means present
            return (char*)m->values + idx * m->val_size;
        }
        idx = (idx + 1) % m->cap;
    }
    return NULL;
}

static inline bool gorget_map_contains(const GorgetMap* m, const void* key) {
    return gorget_map_get(m, key) != NULL;
}

static inline size_t gorget_map_len(const GorgetMap* m) {
    return m->count;
}

static inline bool gorget_map_remove(GorgetMap* m, const void* key) {
    if (m->cap == 0) return false;
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) return false;
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            m->states[idx] = 2;  // tombstone
            m->count--;
            return true;
        }
        idx = (idx + 1) % m->cap;
    }
    return false;
}

static inline void gorget_map_clear(GorgetMap* m) {
    if (m->states) memset(m->states, 0, m->cap);
    m->count = 0;
}

static inline void gorget_map_free(GorgetMap* m) {
    free(m->keys);
    free(m->values);
    free(m->states);
    m->keys = NULL;
    m->values = NULL;
    m->states = NULL;
    m->count = 0;
    m->cap = 0;
}

// ── GorgetSet (thin wrapper over GorgetMap) ───────────────────
typedef GorgetMap GorgetSet;

static inline GorgetSet gorget_set_new(size_t elem_size) {
    return gorget_map_new(elem_size, 0);
}

static inline void gorget_set_add(GorgetSet* s, const void* elem) {
    gorget_map_put(s, elem, NULL);
}

static inline bool gorget_set_contains(const GorgetSet* s, const void* elem) {
    return gorget_map_contains(s, elem);
}

static inline bool gorget_set_remove(GorgetSet* s, const void* elem) {
    return gorget_map_remove(s, elem);
}

static inline void gorget_set_clear(GorgetSet* s) {
    gorget_map_clear(s);
}

static inline size_t gorget_set_len(const GorgetSet* s) {
    return gorget_map_len(s);
}

static inline void gorget_set_free(GorgetSet* s) {
    gorget_map_free(s);
}

// ── Error Handling (setjmp/longjmp) ─────────────────────────
typedef struct {
    char message[256];
    int code;
} GorgetError;

static jmp_buf __gorget_jmp_stack[64];
static int __gorget_jmp_top = -1;
static GorgetError __gorget_last_error;

#define GORGET_TRY (__gorget_jmp_top >= 63 ? (fprintf(stderr, "gorget: try stack overflow\n"), exit(1), 0) : (__gorget_jmp_top++, setjmp(__gorget_jmp_stack[__gorget_jmp_top]) == 0))
#define GORGET_CATCH_END (__gorget_jmp_top--)

static inline void gorget_throw(const char* msg, int code) {
    strncpy(__gorget_last_error.message, msg, 255);
    __gorget_last_error.message[255] = '\0';
    __gorget_last_error.code = code;
    if (__gorget_jmp_top >= 0) {
        longjmp(__gorget_jmp_stack[__gorget_jmp_top], 1);
    } else {
        fprintf(stderr, "Unhandled error: %s\n", msg);
        exit(1);
    }
}

#define GORGET_THROW(msg, code) gorget_throw(msg, code)
#define GORGET_CATCH_ERROR() (__gorget_last_error)

// ── GorgetFile ──────────────────────────────────────────────
typedef struct {
    FILE* handle;
    bool  owned;   // false for stdin/stdout/stderr
} GorgetFile;

static inline GorgetFile gorget_file_open(const char* path, const char* mode) {
    FILE* f = fopen(path, mode);
    if (!f) { fprintf(stderr, "Error: cannot open '%s'\n", path); exit(1); }
    return (GorgetFile){f, true};
}

static inline void gorget_file_close(GorgetFile* f) {
    if (f->handle && f->owned) { fclose(f->handle); f->handle = NULL; }
}

static inline const char* gorget_file_read_all(GorgetFile* f) {
    fseek(f->handle, 0, SEEK_END);
    long len = ftell(f->handle);
    fseek(f->handle, 0, SEEK_SET);
    char* buf = (char*)malloc(len + 1);
    fread(buf, 1, len, f->handle);
    buf[len] = '\0';
    return buf;
}

static inline void gorget_file_write(GorgetFile* f, const char* s) {
    fputs(s, f->handle);
}

// Free functions
static inline const char* gorget_read_file(const char* path) {
    GorgetFile f = gorget_file_open(path, "r");
    const char* content = gorget_file_read_all(&f);
    gorget_file_close(&f);
    return content;
}

static inline void gorget_write_file(const char* path, const char* content) {
    GorgetFile f = gorget_file_open(path, "w");
    gorget_file_write(&f, content);
    gorget_file_close(&f);
}

static inline void gorget_append_file(const char* path, const char* content) {
    GorgetFile f = gorget_file_open(path, "a");
    gorget_file_write(&f, content);
    gorget_file_close(&f);
}

static inline bool gorget_file_exists(const char* path) {
    FILE* f = fopen(path, "r");
    if (f) { fclose(f); return true; }
    return false;
}

static inline bool gorget_delete_file(const char* path) {
    return remove(path) == 0;
}

// ── Path functions ───────────────────────────────────────────
static inline const char* gorget_path_parent(const char* path) {
    if (path == NULL || path[0] == '\0') return ".";
    size_t len = strlen(path);
    // Strip trailing slashes
    while (len > 1 && path[len - 1] == '/') len--;
    // Find last slash
    size_t i = len;
    while (i > 0 && path[i - 1] != '/') i--;
    if (i == 0) return ".";      // no slash → parent is "."
    if (i == 1) return "/";      // root slash
    // Return prefix up to (but not including) the trailing slash
    char* result = (char*)malloc(i);
    memcpy(result, path, i - 1);
    result[i - 1] = '\0';
    return result;
}

static inline const char* gorget_path_basename(const char* path) {
    if (path == NULL || path[0] == '\0') return "";
    size_t len = strlen(path);
    // Strip trailing slashes
    while (len > 1 && path[len - 1] == '/') len--;
    // Find last slash
    size_t i = len;
    while (i > 0 && path[i - 1] != '/') i--;
    size_t blen = len - i;
    char* result = (char*)malloc(blen + 1);
    memcpy(result, path + i, blen);
    result[blen] = '\0';
    return result;
}

static inline const char* gorget_path_extension(const char* path) {
    const char* base = gorget_path_basename(path);
    size_t blen = strlen(base);
    if (blen == 0) return "";
    // Find last dot, skipping leading dot for hidden files
    size_t start = (base[0] == '.') ? 1 : 0;
    const char* dot = NULL;
    for (size_t i = start; i < blen; i++) {
        if (base[i] == '.') dot = base + i;
    }
    if (dot == NULL) return "";
    // Return everything after the dot (not including the dot)
    size_t elen = blen - (size_t)(dot + 1 - base);
    char* result = (char*)malloc(elen + 1);
    memcpy(result, dot + 1, elen);
    result[elen] = '\0';
    return result;
}

static inline const char* gorget_path_stem(const char* path) {
    const char* base = gorget_path_basename(path);
    size_t blen = strlen(base);
    if (blen == 0) return "";
    // Find last dot, skipping leading dot for hidden files
    size_t start = (base[0] == '.') ? 1 : 0;
    const char* dot = NULL;
    for (size_t i = start; i < blen; i++) {
        if (base[i] == '.') dot = base + i;
    }
    if (dot == NULL) return base;
    size_t slen = (size_t)(dot - base);
    char* result = (char*)malloc(slen + 1);
    memcpy(result, base, slen);
    result[slen] = '\0';
    return result;
}

static inline const char* gorget_path_join(const char* a, const char* b) {
    if (a == NULL || a[0] == '\0') return b ? b : "";
    if (b == NULL || b[0] == '\0') return a;
    size_t alen = strlen(a);
    size_t blen = strlen(b);
    // Strip trailing slash from a
    while (alen > 1 && a[alen - 1] == '/') alen--;
    // Strip leading slash from b
    size_t bstart = 0;
    while (bstart < blen && b[bstart] == '/') bstart++;
    size_t rlen = alen + 1 + (blen - bstart);
    char* result = (char*)malloc(rlen + 1);
    memcpy(result, a, alen);
    result[alen] = '/';
    memcpy(result + alen + 1, b + bstart, blen - bstart);
    result[rlen] = '\0';
    return result;
}

// ── readdir ─────────────────────────────────────────────────
static inline GorgetArray gorget_readdir(const char* path) {
    GorgetArray arr = gorget_array_new(sizeof(const char*));
    DIR* d = opendir(path);
    if (!d) { fprintf(stderr, "Error: cannot open directory '%s'\n", path); exit(1); }
    struct dirent* ent;
    while ((ent = readdir(d)) != NULL) {
        if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0) continue;
        size_t nlen = strlen(ent->d_name);
        char* name = (char*)malloc(nlen + 1);
        memcpy(name, ent->d_name, nlen + 1);
        gorget_array_push(&arr, &name);
    }
    closedir(d);
    return arr;
}

// ── CLI args ────────────────────────────────────────────────
static int gorget_argc = 0;
static char** gorget_argv = NULL;

static inline void gorget_init_args(int argc, char** argv) {
    gorget_argc = argc;
    gorget_argv = argv;
}

static inline GorgetArray gorget_args(void) {
    GorgetArray arr = gorget_array_new(sizeof(const char*));
    for (int i = 0; i < gorget_argc; i++) {
        const char* s = gorget_argv[i];
        gorget_array_push(&arr, &s);
    }
    return arr;
}

// ── parse_int ────────────────────────────────────────────────
static inline int64_t gorget_parse_int(const char* s) {
    char* endptr;
    long long result = strtoll(s, &endptr, 10);
    if (*endptr != '\0' && !isspace((unsigned char)*endptr)) {
        fprintf(stderr, "panic: parse_int: invalid integer '%s'\n", s);
        exit(1);
    }
    return (int64_t)result;
}

// ── parse_float ──────────────────────────────────────────────
static inline double gorget_parse_float(const char* s) {
    char* endptr;
    double result = strtod(s, &endptr);
    if (*endptr != '\0' && !isspace((unsigned char)*endptr)) {
        fprintf(stderr, "panic: parse_float: invalid float '%s'\n", s);
        exit(1);
    }
    return result;
}

// ── to_str conversions ──────────────────────────────────────
static inline const char* gorget_int_to_str(int64_t n) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%" PRId64, n);
    size_t len = strlen(buf);
    char* out = (char*)malloc(len + 1);
    memcpy(out, buf, len + 1);
    return out;
}

static inline const char* gorget_float_to_str(double x) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%g", x);
    size_t len = strlen(buf);
    char* out = (char*)malloc(len + 1);
    memcpy(out, buf, len + 1);
    return out;
}

static inline const char* gorget_bool_to_str(bool b) {
    return b ? "true" : "false";
}

static inline const char* gorget_char_to_str(char c) {
    char* out = (char*)malloc(2);
    out[0] = c;
    out[1] = '\0';
    return out;
}

// ── getenv / setenv / getcwd / platform ──────────────────────
static inline const char* gorget_getenv(const char* name) {
    const char* val = getenv(name);
    return val ? val : "";
}

static inline void gorget_setenv(const char* name, const char* value) {
    setenv(name, value, 1);
}

static inline const char* gorget_getcwd(void) {
    char buf[4096];
    if (getcwd(buf, sizeof(buf)) == NULL) return "";
    size_t len = strlen(buf);
    char* out = (char*)malloc(len + 1);
    memcpy(out, buf, len + 1);
    return out;
}

static inline const char* gorget_platform(void) {
#if defined(__APPLE__)
    return "macos";
#elif defined(__linux__)
    return "linux";
#elif defined(_WIN32)
    return "windows";
#elif defined(__FreeBSD__)
    return "freebsd";
#else
    return "unknown";
#endif
}

// ── Interactive I/O ─────────────────────────────────────────
static inline int64_t gorget_rand(void) { return (int64_t)rand(); }
static inline void gorget_seed(int64_t seed) { srand((unsigned int)seed); }
static inline int64_t gorget_rand_range(int64_t lo, int64_t hi) {
    if (lo >= hi) return lo;
    return lo + (int64_t)(rand() % (int)(hi - lo));
}
static inline int64_t gorget_getchar(void) {
    unsigned char c;
    ssize_t n = read(STDIN_FILENO, &c, 1);
    return n <= 0 ? -1 : (int64_t)c;
}
static inline void gorget_sleep_ms(int64_t ms) { usleep((useconds_t)(ms * 1000)); }
static inline int64_t gorget_time(void) { return (int64_t)time(NULL); }
static inline int64_t gorget_time_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (int64_t)ts.tv_sec * 1000 + (int64_t)(ts.tv_nsec / 1000000);
}
static inline int64_t gorget_term_cols(void) { struct winsize ws; if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) return 80; return (int64_t)ws.ws_col; }
static inline int64_t gorget_term_rows(void) { struct winsize ws; if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) return 24; return (int64_t)ws.ws_row; }

// ── Line input ───────────────────────────────────────────────
static inline const char* gorget_readline(void) {
    char buf[4096];
    if (fgets(buf, sizeof(buf), stdin) == NULL) return "";
    size_t len = strlen(buf);
    if (len > 0 && buf[len - 1] == '\n') buf[--len] = '\0';
    char* out = (char*)malloc(len + 1);
    memcpy(out, buf, len + 1);
    return out;
}

static inline const char* gorget_input(const char* prompt) {
    fputs(prompt, stdout);
    fflush(stdout);
    return gorget_readline();
}

// ── Math functions ───────────────────────────────────────────
static inline int64_t gorget_abs(int64_t x) { return x < 0 ? -x : x; }
static inline int64_t gorget_min(int64_t a, int64_t b) { return a < b ? a : b; }
static inline int64_t gorget_max(int64_t a, int64_t b) { return a > b ? a : b; }
static inline double gorget_sqrt(double x) { return sqrt(x); }
static inline double gorget_pow(double base, double exp) { return pow(base, exp); }
static inline double gorget_floor(double x) { return floor(x); }
static inline double gorget_ceil(double x) { return ceil(x); }
static inline double gorget_round(double x) { return round(x); }
static inline double gorget_log(double x) { return log(x); }
static inline double gorget_log2(double x) { return log2(x); }
static inline double gorget_log10(double x) { return log10(x); }
static inline double gorget_sin(double x) { return sin(x); }
static inline double gorget_cos(double x) { return cos(x); }
static inline double gorget_tan(double x) { return tan(x); }
static inline double gorget_asin(double x) { return asin(x); }
static inline double gorget_acos(double x) { return acos(x); }
static inline double gorget_atan(double x) { return atan(x); }
static inline double gorget_atan2(double y, double x) { return atan2(y, x); }
static inline double gorget_fabs(double x) { return fabs(x); }
static inline double gorget_fmin(double a, double b) { return fmin(a, b); }
static inline double gorget_fmax(double a, double b) { return fmax(a, b); }

// ── Array sort comparators ───────────────────────────────────
static int __gorget_cmp_i64(const void* a, const void* b) {
    int64_t va = *(const int64_t*)a, vb = *(const int64_t*)b;
    return (va > vb) - (va < vb);
}
static int __gorget_cmp_f64(const void* a, const void* b) {
    double va = *(const double*)a, vb = *(const double*)b;
    return (va > vb) - (va < vb);
}
static int __gorget_cmp_str(const void* a, const void* b) {
    const char* sa = *(const char* const*)a;
    const char* sb = *(const char* const*)b;
    return strcmp(sa, sb);
}
static int __gorget_cmp_char(const void* a, const void* b) {
    char ca = *(const char*)a, cb = *(const char*)b;
    return (ca > cb) - (ca < cb);
}
static int __gorget_cmp_bool(const void* a, const void* b) {
    bool ba = *(const bool*)a, bb = *(const bool*)b;
    return (int)ba - (int)bb;
}

static inline void gorget_array_reverse(GorgetArray* arr) {
    if (arr->len <= 1) return;
    char tmp[arr->elem_size];
    for (size_t i = 0, j = arr->len - 1; i < j; i++, j--) {
        char* a = (char*)arr->data + i * arr->elem_size;
        char* b = (char*)arr->data + j * arr->elem_size;
        memcpy(tmp, a, arr->elem_size);
        memcpy(a, b, arr->elem_size);
        memcpy(b, tmp, arr->elem_size);
    }
}

// ── GorgetClosure ────────────────────────────────────────────
typedef struct {
    void* fn_ptr;
    void* env;
} GorgetClosure;

"#;

/// Trace runtime emitted only when `directive trace` or `--trace` is active.
pub const TRACE_RUNTIME: &str = r#"
// ── Gorget Trace Runtime ──────────────────────────────────────
static FILE* __gorget_trace_fp = NULL;
static int __gorget_trace_depth = 0;

static void __gorget_trace_close(void) {
    if (__gorget_trace_fp && __gorget_trace_fp != stderr) fclose(__gorget_trace_fp);
    __gorget_trace_fp = NULL;
}

static void __gorget_trace_init(const char* path) {
    __gorget_trace_fp = fopen(path, "w");
    if (!__gorget_trace_fp) __gorget_trace_fp = stderr;
    atexit(__gorget_trace_close);
}

static void __gorget_trace_json_str(FILE* fp, const char* s) {
    while (*s) {
        switch (*s) {
            case '"':  fputs("\\\"", fp); break;
            case '\\': fputs("\\\\", fp); break;
            case '\n': fputs("\\n", fp); break;
            default:   fputc(*s, fp);
        }
        s++;
    }
}

static void __gorget_trace_val_int(FILE* fp, int64_t v) { fprintf(fp, "%" PRId64, v); }
static void __gorget_trace_val_float(FILE* fp, double v) { fprintf(fp, "%g", v); }
static void __gorget_trace_val_bool(FILE* fp, bool v) { fprintf(fp, v ? "true" : "false"); }
static void __gorget_trace_val_str(FILE* fp, const char* v) {
    fputc('"', fp);
    if (v) {
        for (const char* p = v; *p; p++) {
            if (*p == '"') fputs("\\\"", fp);
            else if (*p == '\\') fputs("\\\\", fp);
            else if (*p == '\n') fputs("\\n", fp);
            else if (*p == '\t') fputs("\\t", fp);
            else fputc(*p, fp);
        }
    }
    fputc('"', fp);
}
static void __gorget_trace_val_char(FILE* fp, char v) { fprintf(fp, "'%c'", v); }
static void __gorget_trace_val_void(FILE* fp) { (void)fp; }

"#;

/// C runtime for std.process — process execution (exec, exec_output).
pub const PROCESS_RUNTIME: &str = r#"
// ── std.process runtime ──────────────────────────────────────
static inline int64_t gorget_exec(const char* cmd) {
    int status = system(cmd);
    if (status == -1) return -1;
    #ifdef _WIN32
    return (int64_t)status;
    #else
    return WIFEXITED(status) ? (int64_t)WEXITSTATUS(status) : (int64_t)-1;
    #endif
}

typedef struct ExecResult {
    const char* output;
    const char* errors;
    int64_t exit_code;
} ExecResult;

static inline ExecResult gorget_exec_output(const char* cmd) {
    ExecResult result;
    result.errors = "";

    // Capture stdout via popen
    FILE* __proc_fp = popen(cmd, "r");
    if (!__proc_fp) {
        result.output = "";
        result.exit_code = -1;
        return result;
    }

    // Read all stdout
    size_t cap = 256;
    size_t len = 0;
    char* buf = (char*)malloc(cap);
    size_t n;
    while ((n = fread(buf + len, 1, cap - len - 1, __proc_fp)) > 0) {
        len += n;
        if (len + 1 >= cap) {
            cap *= 2;
            buf = (char*)realloc(buf, cap);
        }
    }
    buf[len] = '\0';

    int status = pclose(__proc_fp);
    result.exit_code = WIFEXITED(status) ? (int64_t)WEXITSTATUS(status) : -1;
    result.output = buf;
    return result;
}
"#;
