/// Embedded runtime header included at the top of every generated C file.
pub const RUNTIME: &str = r#"// Generated by Vyper compiler v0.1.0
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <inttypes.h>
#include <stdarg.h>
#include <setjmp.h>

// ── VyperString ─────────────────────────────────────────────
typedef struct {
    char* data;
    size_t len;
    size_t cap;
} VyperString;

static inline VyperString vyper_string_new(const char* s) {
    size_t len = strlen(s);
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, s, len + 1);
    return (VyperString){data, len, cap};
}

static inline void vyper_string_free(VyperString* s) {
    free(s->data);
    s->data = NULL;
    s->len = 0;
    s->cap = 0;
}

static inline VyperString vyper_string_concat(const VyperString* a, const VyperString* b) {
    size_t len = a->len + b->len;
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, a->data, a->len);
    memcpy(data + a->len, b->data, b->len + 1);
    return (VyperString){data, len, cap};
}

static inline bool vyper_string_eq(const VyperString* a, const VyperString* b) {
    return a->len == b->len && memcmp(a->data, b->data, a->len) == 0;
}

// ── VyperArray ──────────────────────────────────────────────
typedef struct {
    void* data;
    size_t len;
    size_t cap;
    size_t elem_size;
} VyperArray;

static inline VyperArray vyper_array_new(size_t elem_size) {
    return (VyperArray){NULL, 0, 0, elem_size};
}

static inline void vyper_array_push(VyperArray* arr, const void* elem) {
    if (arr->len >= arr->cap) {
        size_t new_cap = arr->cap == 0 ? 8 : arr->cap * 2;
        arr->data = realloc(arr->data, new_cap * arr->elem_size);
        arr->cap = new_cap;
    }
    memcpy((char*)arr->data + arr->len * arr->elem_size, elem, arr->elem_size);
    arr->len++;
}

static inline void* vyper_array_get(const VyperArray* arr, size_t index) {
    return (char*)arr->data + index * arr->elem_size;
}

static inline size_t vyper_array_len(const VyperArray* arr) {
    return arr->len;
}

static inline void vyper_array_free(VyperArray* arr) {
    free(arr->data);
    arr->data = NULL;
    arr->len = 0;
    arr->cap = 0;
}

// ── Error Handling (setjmp/longjmp) ─────────────────────────
typedef struct {
    char message[256];
    int code;
} VyperError;

static jmp_buf __vyper_jmp_stack[64];
static int __vyper_jmp_top = -1;
static VyperError __vyper_last_error;

#define VYPER_TRY (__vyper_jmp_top++, setjmp(__vyper_jmp_stack[__vyper_jmp_top]) == 0)
#define VYPER_CATCH_END (__vyper_jmp_top--)

static inline void vyper_throw(const char* msg, int code) {
    strncpy(__vyper_last_error.message, msg, 255);
    __vyper_last_error.message[255] = '\0';
    __vyper_last_error.code = code;
    if (__vyper_jmp_top >= 0) {
        longjmp(__vyper_jmp_stack[__vyper_jmp_top], 1);
    } else {
        fprintf(stderr, "Unhandled error: %s\n", msg);
        exit(1);
    }
}

#define VYPER_THROW(msg, code) vyper_throw(msg, code)
#define VYPER_CATCH_ERROR() (__vyper_last_error)

// ── VyperClosure ────────────────────────────────────────────
typedef struct {
    void* fn_ptr;
    void* env;
} VyperClosure;

"#;
