/// Embedded runtime header included at the top of every generated C file.
pub const RUNTIME: &str = r#"// Generated by Gorget compiler v0.1.0
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <inttypes.h>
#include <stdarg.h>
#include <setjmp.h>
#include <dirent.h>
#include <ctype.h>
#include <sys/wait.h>

// ── GorgetString ─────────────────────────────────────────────
typedef struct {
    char* data;
    size_t len;
    size_t cap;
} GorgetString;

static inline GorgetString gorget_string_new(const char* s) {
    if (s == NULL) return (GorgetString){NULL, 0, 0};
    size_t len = strlen(s);
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, s, len + 1);
    return (GorgetString){data, len, cap};
}

static inline void gorget_string_free(GorgetString* s) {
    free(s->data);
    s->data = NULL;
    s->len = 0;
    s->cap = 0;
}

static inline GorgetString gorget_string_concat(const GorgetString* a, const GorgetString* b) {
    size_t len = a->len + b->len;
    size_t cap = len + 1;
    char* data = (char*)malloc(cap);
    memcpy(data, a->data, a->len);
    memcpy(data + a->len, b->data, b->len + 1);
    return (GorgetString){data, len, cap};
}

static inline bool gorget_string_eq(const GorgetString* a, const GorgetString* b) {
    return a->len == b->len && memcmp(a->data, b->data, a->len) == 0;
}

static inline const char* gorget_string_cstr(const GorgetString* s) {
    return s->data;
}

static inline GorgetString gorget_string_format(const char* fmt, ...) {
    va_list args1, args2;
    va_start(args1, fmt);
    va_copy(args2, args1);
    int len = vsnprintf(NULL, 0, fmt, args1);
    va_end(args1);
    size_t cap = (size_t)len + 1;
    char* data = (char*)malloc(cap);
    vsnprintf(data, cap, fmt, args2);
    va_end(args2);
    return (GorgetString){data, (size_t)len, cap};
}

static inline const char* gorget_format(const char* fmt, ...) {
    va_list args1, args2;
    va_start(args1, fmt);
    va_copy(args2, args1);
    int len = vsnprintf(NULL, 0, fmt, args1);
    va_end(args1);
    char* data = (char*)malloc((size_t)len + 1);
    vsnprintf(data, (size_t)len + 1, fmt, args2);
    va_end(args2);
    return data;
}

// ── String concatenation ────────────────────────────────────
static inline const char* gorget_str_concat(const char* a, const char* b) {
    size_t la = strlen(a), lb = strlen(b);
    char* out = (char*)malloc(la + lb + 1);
    memcpy(out, a, la);
    memcpy(out + la, b, lb + 1);
    return out;
}

// ── String helpers ──────────────────────────────────────────
static inline bool gorget_string_starts_with(const char* s, const char* prefix) {
    return strncmp(s, prefix, strlen(prefix)) == 0;
}

static inline bool gorget_string_ends_with(const char* s, const char* suffix) {
    size_t slen = strlen(s), plen = strlen(suffix);
    if (plen > slen) return false;
    return memcmp(s + slen - plen, suffix, plen) == 0;
}

static inline const char* gorget_string_trim(const char* s) {
    while (*s == ' ' || *s == '\t' || *s == '\n' || *s == '\r') s++;
    size_t len = strlen(s);
    while (len > 0 && (s[len-1] == ' ' || s[len-1] == '\t' || s[len-1] == '\n' || s[len-1] == '\r')) len--;
    char* out = (char*)malloc(len + 1);
    memcpy(out, s, len);
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_to_upper(const char* s) {
    size_t len = strlen(s);
    char* out = (char*)malloc(len + 1);
    for (size_t i = 0; i < len; i++) out[i] = (s[i] >= 'a' && s[i] <= 'z') ? s[i] - 32 : s[i];
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_to_lower(const char* s) {
    size_t len = strlen(s);
    char* out = (char*)malloc(len + 1);
    for (size_t i = 0; i < len; i++) out[i] = (s[i] >= 'A' && s[i] <= 'Z') ? s[i] + 32 : s[i];
    out[len] = '\0';
    return out;
}

static inline const char* gorget_string_replace(const char* s, const char* old, const char* new_s) {
    size_t old_len = strlen(old);
    size_t new_len = strlen(new_s);
    if (old_len == 0) {
        char* dup = (char*)malloc(strlen(s) + 1);
        strcpy(dup, s);
        return dup;
    }
    // Count occurrences
    size_t count = 0;
    const char* p = s;
    while ((p = strstr(p, old)) != NULL) { count++; p += old_len; }
    // Build result
    size_t result_len = strlen(s) + count * (new_len - old_len);
    char* out = (char*)malloc(result_len + 1);
    char* dst = out;
    p = s;
    while (1) {
        const char* found = strstr(p, old);
        if (!found) { strcpy(dst, p); break; }
        size_t chunk = (size_t)(found - p);
        memcpy(dst, p, chunk);
        dst += chunk;
        memcpy(dst, new_s, new_len);
        dst += new_len;
        p = found + old_len;
    }
    return out;
}

// ── String indexing / slicing ────────────────────────────────
static inline char gorget_string_at(const char* s, int64_t index) {
    size_t len = strlen(s);
    if (index < 0 || (size_t)index >= len) {
        fprintf(stderr, "gorget: panic: string index out of bounds: index %" PRId64 ", length %zu\n", index, len);
        exit(1);
    }
    return s[index];
}

static inline const char* gorget_string_slice(const char* s, int64_t start, int64_t end) {
    size_t len = strlen(s);
    if (start < 0 || end < 0 || (size_t)start > len || (size_t)end > len || start > end) {
        fprintf(stderr, "gorget: panic: string slice out of bounds: [%" PRId64 "..%" PRId64 "], length %zu\n", start, end, len);
        exit(1);
    }
    size_t slice_len = (size_t)(end - start);
    char* result = (char*)malloc(slice_len + 1);
    memcpy(result, s + start, slice_len);
    result[slice_len] = '\0';
    return result;
}

// ── Panic helper ─────────────────────────────────────────────
static inline void gorget_panic(const char* msg) {
    fprintf(stderr, "gorget: panic: %s\n", msg);
    exit(1);
}

// ── Checked Arithmetic ──────────────────────────────────────
// Inline helpers call __builtin_*_overflow (integer-only).
// _Generic macros dispatch: integer types → checked, double → plain.
// Both branches are valid C, so Clang type-checks them safely.
static inline int64_t gorget_checked_add_i64(int64_t a, int64_t b) {
    int64_t res;
    if (__builtin_add_overflow(a, b, &res)) gorget_panic("integer overflow");
    return res;
}
static inline int64_t gorget_checked_sub_i64(int64_t a, int64_t b) {
    int64_t res;
    if (__builtin_sub_overflow(a, b, &res)) gorget_panic("integer overflow");
    return res;
}
static inline int64_t gorget_checked_mul_i64(int64_t a, int64_t b) {
    int64_t res;
    if (__builtin_mul_overflow(a, b, &res)) gorget_panic("integer overflow");
    return res;
}

#define GORGET_CHECKED_ADD(a, b) _Generic((a), \
    long long: gorget_checked_add_i64((a), (b)), \
    long: gorget_checked_add_i64((a), (b)), \
    default: ((a) + (b)))

#define GORGET_CHECKED_SUB(a, b) _Generic((a), \
    long long: gorget_checked_sub_i64((a), (b)), \
    long: gorget_checked_sub_i64((a), (b)), \
    default: ((a) - (b)))

#define GORGET_CHECKED_MUL(a, b) _Generic((a), \
    long long: gorget_checked_mul_i64((a), (b)), \
    long: gorget_checked_mul_i64((a), (b)), \
    default: ((a) * (b)))

#define GORGET_CHECKED_ADD_ASSIGN(t, v) \
    ((t) = _Generic((t), \
        long long: gorget_checked_add_i64((t), (v)), \
        long: gorget_checked_add_i64((t), (v)), \
        default: ((t) + (v))))

#define GORGET_CHECKED_SUB_ASSIGN(t, v) \
    ((t) = _Generic((t), \
        long long: gorget_checked_sub_i64((t), (v)), \
        long: gorget_checked_sub_i64((t), (v)), \
        default: ((t) - (v))))

#define GORGET_CHECKED_MUL_ASSIGN(t, v) \
    ((t) = _Generic((t), \
        long long: gorget_checked_mul_i64((t), (v)), \
        long: gorget_checked_mul_i64((t), (v)), \
        default: ((t) * (v))))

// ── GorgetArray ──────────────────────────────────────────────
typedef struct {
    void* data;
    size_t len;
    size_t cap;
    size_t elem_size;
} GorgetArray;

static inline GorgetArray gorget_array_new(size_t elem_size) {
    return (GorgetArray){NULL, 0, 0, elem_size};
}

static inline void gorget_array_push(GorgetArray* arr, const void* elem) {
    if (arr->len >= arr->cap) {
        size_t new_cap = arr->cap == 0 ? 8 : arr->cap * 2;
        arr->data = realloc(arr->data, new_cap * arr->elem_size);
        arr->cap = new_cap;
    }
    memcpy((char*)arr->data + arr->len * arr->elem_size, elem, arr->elem_size);
    arr->len++;
}

static inline void* gorget_array_get(const GorgetArray* arr, size_t index) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    return (char*)arr->data + index * arr->elem_size;
}

static inline size_t gorget_array_len(const GorgetArray* arr) {
    return arr->len;
}

static inline void gorget_array_set(GorgetArray* arr, size_t index, const void* elem) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    memcpy((char*)arr->data + index * arr->elem_size, elem, arr->elem_size);
}

static inline void gorget_array_remove(GorgetArray* arr, size_t index) {
    if (index >= arr->len) {
        fprintf(stderr, "gorget: panic: index out of bounds: index %zu, length %zu\n", index, arr->len);
        exit(1);
    }
    if (index + 1 < arr->len) {
        memmove((char*)arr->data + index * arr->elem_size,
                (char*)arr->data + (index + 1) * arr->elem_size,
                (arr->len - index - 1) * arr->elem_size);
    }
    arr->len--;
}

static inline void gorget_array_clear(GorgetArray* arr) {
    arr->len = 0;
}

static inline void gorget_array_free(GorgetArray* arr) {
    free(arr->data);
    arr->data = NULL;
    arr->len = 0;
    arr->cap = 0;
}

static inline bool gorget_array_contains(const GorgetArray* a, const void* needle, size_t elem_size) {
    for (size_t i = 0; i < a->len; i++) {
        if (memcmp((char*)a->data + i * a->elem_size, needle, elem_size) == 0) return true;
    }
    return false;
}

static inline void gorget_array_reserve(GorgetArray* arr, size_t new_cap) {
    if (new_cap > arr->cap) {
        arr->data = realloc(arr->data, new_cap * arr->elem_size);
        arr->cap = new_cap;
    }
}

static inline GorgetArray gorget_array_with_capacity(size_t elem_size, size_t capacity) {
    GorgetArray arr = {NULL, 0, 0, elem_size};
    if (capacity > 0) {
        arr.data = malloc(capacity * elem_size);
        arr.cap = capacity;
    }
    return arr;
}

static inline GorgetArray gorget_array_slice(const GorgetArray* arr, int64_t start, int64_t end) {
    if (start < 0 || end < 0 || (size_t)start > arr->len || (size_t)end > arr->len || start > end) {
        fprintf(stderr, "gorget: panic: vector slice out of bounds: [%" PRId64 "..%" PRId64 "], length %zu\n", start, end, arr->len);
        exit(1);
    }
    size_t slice_len = (size_t)(end - start);
    GorgetArray result = {NULL, 0, 0, arr->elem_size};
    if (slice_len > 0) {
        result.data = malloc(slice_len * arr->elem_size);
        memcpy(result.data, (char*)arr->data + (size_t)start * arr->elem_size, slice_len * arr->elem_size);
        result.len = slice_len;
        result.cap = slice_len;
    }
    return result;
}

static inline GorgetArray gorget_string_split(const char* s, const char* delim) {
    GorgetArray arr = gorget_array_new(sizeof(const char*));
    size_t dlen = strlen(delim);
    if (dlen == 0) {
        size_t slen = strlen(s);
        for (size_t i = 0; i < slen; i++) {
            char* ch = (char*)malloc(2);
            ch[0] = s[i]; ch[1] = '\0';
            gorget_array_push(&arr, &ch);
        }
        return arr;
    }
    const char* p = s;
    while (1) {
        const char* found = strstr(p, delim);
        if (!found) {
            size_t rem = strlen(p);
            char* part = (char*)malloc(rem + 1);
            memcpy(part, p, rem + 1);
            gorget_array_push(&arr, &part);
            break;
        }
        size_t chunk = (size_t)(found - p);
        char* part = (char*)malloc(chunk + 1);
        memcpy(part, p, chunk);
        part[chunk] = '\0';
        gorget_array_push(&arr, &part);
        p = found + dlen;
    }
    return arr;
}

// ── GORGET_ARRAY_AT macro ────────────────────────────────────
#define GORGET_ARRAY_AT(type, arr, i) (*(type*)gorget_array_get(&(arr), (i)))

// ── GorgetMap (open-addressing hash map) ─────────────────────
typedef struct {
    void* keys;
    void* values;
    uint8_t* states;  // 0=empty, 1=occupied, 2=tombstone
    size_t count;
    size_t cap;
    size_t key_size;
    size_t val_size;
} GorgetMap;

static inline uint64_t __gorget_fnv1a(const void* data, size_t len) {
    uint64_t hash = 14695981039346656037ULL;
    const uint8_t* p = (const uint8_t*)data;
    for (size_t i = 0; i < len; i++) {
        hash ^= p[i];
        hash *= 1099511628211ULL;
    }
    return hash;
}

static inline uint64_t __gorget_hash_str(const char* s) {
    uint64_t hash = 14695981039346656037ULL;
    while (*s) { hash ^= (uint8_t)*s++; hash *= 1099511628211ULL; }
    return hash;
}

static inline void __gorget_map_grow(GorgetMap* m) {
    size_t old_cap = m->cap;
    void* old_keys = m->keys;
    void* old_values = m->values;
    uint8_t* old_states = m->states;

    size_t new_cap = old_cap == 0 ? 16 : old_cap * 2;
    m->keys = calloc(new_cap, m->key_size);
    m->values = m->val_size > 0 ? calloc(new_cap, m->val_size) : NULL;
    m->states = (uint8_t*)calloc(new_cap, 1);
    m->cap = new_cap;
    m->count = 0;

    for (size_t i = 0; i < old_cap; i++) {
        if (old_states[i] == 1) {
            const void* key = (const char*)old_keys + i * m->key_size;
            uint64_t h = __gorget_fnv1a(key, m->key_size);
            size_t idx = (size_t)(h % new_cap);
            while (m->states[idx] != 0) {
                idx = (idx + 1) % new_cap;
            }
            memcpy((char*)m->keys + idx * m->key_size, key, m->key_size);
            if (m->val_size > 0) {
                const void* val = (const char*)old_values + i * m->val_size;
                memcpy((char*)m->values + idx * m->val_size, val, m->val_size);
            }
            m->states[idx] = 1;
            m->count++;
        }
    }

    free(old_keys);
    free(old_values);
    free(old_states);
}

static inline GorgetMap gorget_map_new(size_t key_size, size_t val_size) {
    return (GorgetMap){NULL, NULL, NULL, 0, 0, key_size, val_size};
}

static inline void gorget_map_put(GorgetMap* m, const void* key, const void* value) {
    if (m->cap == 0 || m->count * 4 >= m->cap * 3) {
        __gorget_map_grow(m);
    }
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    size_t first_tombstone = (size_t)-1;
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) {
            size_t target = first_tombstone != (size_t)-1 ? first_tombstone : idx;
            memcpy((char*)m->keys + target * m->key_size, key, m->key_size);
            if (m->val_size > 0 && value != NULL) {
                memcpy((char*)m->values + target * m->val_size, value, m->val_size);
            }
            m->states[target] = 1;
            m->count++;
            return;
        }
        if (m->states[idx] == 2 && first_tombstone == (size_t)-1) {
            first_tombstone = idx;
        }
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            if (m->val_size > 0 && value != NULL) {
                memcpy((char*)m->values + idx * m->val_size, value, m->val_size);
            }
            return;
        }
        idx = (idx + 1) % m->cap;
    }
    if (first_tombstone != (size_t)-1) {
        memcpy((char*)m->keys + first_tombstone * m->key_size, key, m->key_size);
        if (m->val_size > 0 && value != NULL) {
            memcpy((char*)m->values + first_tombstone * m->val_size, value, m->val_size);
        }
        m->states[first_tombstone] = 1;
        m->count++;
    }
}

static inline void* gorget_map_get(const GorgetMap* m, const void* key) {
    if (m->cap == 0) return NULL;
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) return NULL;
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            if (m->val_size == 0) return (void*)1;  // Set mode: non-NULL means present
            return (char*)m->values + idx * m->val_size;
        }
        idx = (idx + 1) % m->cap;
    }
    return NULL;
}

static inline bool gorget_map_contains(const GorgetMap* m, const void* key) {
    return gorget_map_get(m, key) != NULL;
}

static inline size_t gorget_map_len(const GorgetMap* m) {
    return m->count;
}

static inline bool gorget_map_remove(GorgetMap* m, const void* key) {
    if (m->cap == 0) return false;
    uint64_t h = __gorget_fnv1a(key, m->key_size);
    size_t idx = (size_t)(h % m->cap);
    for (size_t __probes = 0; __probes < m->cap; __probes++) {
        if (m->states[idx] == 0) return false;
        if (m->states[idx] == 1 && memcmp((const char*)m->keys + idx * m->key_size, key, m->key_size) == 0) {
            m->states[idx] = 2;  // tombstone
            m->count--;
            return true;
        }
        idx = (idx + 1) % m->cap;
    }
    return false;
}

static inline void gorget_map_clear(GorgetMap* m) {
    if (m->states) memset(m->states, 0, m->cap);
    m->count = 0;
}

static inline void gorget_map_free(GorgetMap* m) {
    free(m->keys);
    free(m->values);
    free(m->states);
    m->keys = NULL;
    m->values = NULL;
    m->states = NULL;
    m->count = 0;
    m->cap = 0;
}

// ── GorgetSet (thin wrapper over GorgetMap) ───────────────────
typedef GorgetMap GorgetSet;

static inline GorgetSet gorget_set_new(size_t elem_size) {
    return gorget_map_new(elem_size, 0);
}

static inline void gorget_set_add(GorgetSet* s, const void* elem) {
    gorget_map_put(s, elem, NULL);
}

static inline bool gorget_set_contains(const GorgetSet* s, const void* elem) {
    return gorget_map_contains(s, elem);
}

static inline bool gorget_set_remove(GorgetSet* s, const void* elem) {
    return gorget_map_remove(s, elem);
}

static inline void gorget_set_clear(GorgetSet* s) {
    gorget_map_clear(s);
}

static inline size_t gorget_set_len(const GorgetSet* s) {
    return gorget_map_len(s);
}

static inline void gorget_set_free(GorgetSet* s) {
    gorget_map_free(s);
}

// ── Error Handling (setjmp/longjmp) ─────────────────────────
typedef struct {
    char message[256];
    int code;
} GorgetError;

static jmp_buf __gorget_jmp_stack[64];
static int __gorget_jmp_top = -1;
static GorgetError __gorget_last_error;

#define GORGET_TRY (__gorget_jmp_top >= 63 ? (fprintf(stderr, "gorget: try stack overflow\n"), exit(1), 0) : (__gorget_jmp_top++, setjmp(__gorget_jmp_stack[__gorget_jmp_top]) == 0))
#define GORGET_CATCH_END (__gorget_jmp_top--)

static inline void gorget_throw(const char* msg, int code) {
    strncpy(__gorget_last_error.message, msg, 255);
    __gorget_last_error.message[255] = '\0';
    __gorget_last_error.code = code;
    if (__gorget_jmp_top >= 0) {
        longjmp(__gorget_jmp_stack[__gorget_jmp_top], 1);
    } else {
        fprintf(stderr, "Unhandled error: %s\n", msg);
        exit(1);
    }
}

#define GORGET_THROW(msg, code) gorget_throw(msg, code)
#define GORGET_CATCH_ERROR() (__gorget_last_error)

// ── GorgetFile ──────────────────────────────────────────────
typedef struct {
    FILE* handle;
    bool  owned;   // false for stdin/stdout/stderr
} GorgetFile;

static inline GorgetFile gorget_file_open(const char* path, const char* mode) {
    FILE* f = fopen(path, mode);
    if (!f) { fprintf(stderr, "Error: cannot open '%s'\n", path); exit(1); }
    return (GorgetFile){f, true};
}

static inline void gorget_file_close(GorgetFile* f) {
    if (f->handle && f->owned) { fclose(f->handle); f->handle = NULL; }
}

static inline const char* gorget_file_read_all(GorgetFile* f) {
    fseek(f->handle, 0, SEEK_END);
    long len = ftell(f->handle);
    fseek(f->handle, 0, SEEK_SET);
    char* buf = (char*)malloc(len + 1);
    fread(buf, 1, len, f->handle);
    buf[len] = '\0';
    return buf;
}

static inline void gorget_file_write(GorgetFile* f, const char* s) {
    fputs(s, f->handle);
}

// Free functions
static inline const char* gorget_read_file(const char* path) {
    GorgetFile f = gorget_file_open(path, "r");
    const char* content = gorget_file_read_all(&f);
    gorget_file_close(&f);
    return content;
}

static inline void gorget_write_file(const char* path, const char* content) {
    GorgetFile f = gorget_file_open(path, "w");
    gorget_file_write(&f, content);
    gorget_file_close(&f);
}

static inline void gorget_append_file(const char* path, const char* content) {
    GorgetFile f = gorget_file_open(path, "a");
    gorget_file_write(&f, content);
    gorget_file_close(&f);
}

static inline bool gorget_file_exists(const char* path) {
    FILE* f = fopen(path, "r");
    if (f) { fclose(f); return true; }
    return false;
}

static inline bool gorget_delete_file(const char* path) {
    return remove(path) == 0;
}

// ── Path functions ───────────────────────────────────────────
static inline const char* gorget_path_parent(const char* path) {
    if (path == NULL || path[0] == '\0') return ".";
    size_t len = strlen(path);
    // Strip trailing slashes
    while (len > 1 && path[len - 1] == '/') len--;
    // Find last slash
    size_t i = len;
    while (i > 0 && path[i - 1] != '/') i--;
    if (i == 0) return ".";      // no slash → parent is "."
    if (i == 1) return "/";      // root slash
    // Return prefix up to (but not including) the trailing slash
    char* result = (char*)malloc(i);
    memcpy(result, path, i - 1);
    result[i - 1] = '\0';
    return result;
}

static inline const char* gorget_path_basename(const char* path) {
    if (path == NULL || path[0] == '\0') return "";
    size_t len = strlen(path);
    // Strip trailing slashes
    while (len > 1 && path[len - 1] == '/') len--;
    // Find last slash
    size_t i = len;
    while (i > 0 && path[i - 1] != '/') i--;
    size_t blen = len - i;
    char* result = (char*)malloc(blen + 1);
    memcpy(result, path + i, blen);
    result[blen] = '\0';
    return result;
}

static inline const char* gorget_path_extension(const char* path) {
    const char* base = gorget_path_basename(path);
    size_t blen = strlen(base);
    if (blen == 0) return "";
    // Find last dot, skipping leading dot for hidden files
    size_t start = (base[0] == '.') ? 1 : 0;
    const char* dot = NULL;
    for (size_t i = start; i < blen; i++) {
        if (base[i] == '.') dot = base + i;
    }
    if (dot == NULL) return "";
    // Return everything after the dot (not including the dot)
    size_t elen = blen - (size_t)(dot + 1 - base);
    char* result = (char*)malloc(elen + 1);
    memcpy(result, dot + 1, elen);
    result[elen] = '\0';
    return result;
}

static inline const char* gorget_path_stem(const char* path) {
    const char* base = gorget_path_basename(path);
    size_t blen = strlen(base);
    if (blen == 0) return "";
    // Find last dot, skipping leading dot for hidden files
    size_t start = (base[0] == '.') ? 1 : 0;
    const char* dot = NULL;
    for (size_t i = start; i < blen; i++) {
        if (base[i] == '.') dot = base + i;
    }
    if (dot == NULL) return base;
    size_t slen = (size_t)(dot - base);
    char* result = (char*)malloc(slen + 1);
    memcpy(result, base, slen);
    result[slen] = '\0';
    return result;
}

static inline const char* gorget_path_join(const char* a, const char* b) {
    if (a == NULL || a[0] == '\0') return b ? b : "";
    if (b == NULL || b[0] == '\0') return a;
    size_t alen = strlen(a);
    size_t blen = strlen(b);
    // Strip trailing slash from a
    while (alen > 1 && a[alen - 1] == '/') alen--;
    // Strip leading slash from b
    size_t bstart = 0;
    while (bstart < blen && b[bstart] == '/') bstart++;
    size_t rlen = alen + 1 + (blen - bstart);
    char* result = (char*)malloc(rlen + 1);
    memcpy(result, a, alen);
    result[alen] = '/';
    memcpy(result + alen + 1, b + bstart, blen - bstart);
    result[rlen] = '\0';
    return result;
}

// ── readdir ─────────────────────────────────────────────────
static inline GorgetArray gorget_readdir(const char* path) {
    GorgetArray arr = gorget_array_new(sizeof(const char*));
    DIR* d = opendir(path);
    if (!d) { fprintf(stderr, "Error: cannot open directory '%s'\n", path); exit(1); }
    struct dirent* ent;
    while ((ent = readdir(d)) != NULL) {
        if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0) continue;
        size_t nlen = strlen(ent->d_name);
        char* name = (char*)malloc(nlen + 1);
        memcpy(name, ent->d_name, nlen + 1);
        gorget_array_push(&arr, &name);
    }
    closedir(d);
    return arr;
}

// ── CLI args ────────────────────────────────────────────────
static int gorget_argc = 0;
static char** gorget_argv = NULL;

static inline void gorget_init_args(int argc, char** argv) {
    gorget_argc = argc;
    gorget_argv = argv;
}

static inline GorgetArray gorget_args(void) {
    GorgetArray arr = gorget_array_new(sizeof(const char*));
    for (int i = 0; i < gorget_argc; i++) {
        const char* s = gorget_argv[i];
        gorget_array_push(&arr, &s);
    }
    return arr;
}

// ── exec ─────────────────────────────────────────────────────
static inline int64_t gorget_exec(const char* cmd) {
    int status = system(cmd);
    if (status == -1) return -1;
    #ifdef _WIN32
    return (int64_t)status;
    #else
    return WIFEXITED(status) ? (int64_t)WEXITSTATUS(status) : (int64_t)-1;
    #endif
}

// ── parse_int ────────────────────────────────────────────────
static inline int64_t gorget_parse_int(const char* s) {
    char* endptr;
    long long result = strtoll(s, &endptr, 10);
    if (*endptr != '\0' && !isspace((unsigned char)*endptr)) {
        fprintf(stderr, "panic: parse_int: invalid integer '%s'\n", s);
        exit(1);
    }
    return (int64_t)result;
}

// ── getenv ───────────────────────────────────────────────────
static inline const char* gorget_getenv(const char* name) {
    const char* val = getenv(name);
    return val ? val : "";
}

// ── GorgetClosure ────────────────────────────────────────────
typedef struct {
    void* fn_ptr;
    void* env;
} GorgetClosure;

"#;
